/* Complied on Kernel Version 4.15.0 -45 */
#include <linux/types.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/kdev_t.h>
#include <linux/kernel.h>       
#include <linux/module.h> 
#include <linux/cdev.h>
#include <linux/fs.h>
#include <asm/uaccess.h> 
#include <linux/uaccess.h>
#include "chardev.h"
#include <linux/random.h>


uint8_t channel_no;
char alignment;

static dev_t first;            // variable for device number
static struct cdev c_dev;      // variable for the character device structure
static struct class *cls;
uint16_t local_buffer;        // local buffer for storing ADC data in L/R format 
uint16_t adc_value;            // 10bit no. generated by RNG





static int a_open(struct inode *i, struct file *f)
{

        printk(KERN_INFO "Device file opened \n");
        return 0;
}


static int a_release(struct inode *i, struct file *f)
{

    printk(KERN_INFO "Device file released\n");
    return 0;
}



static ssize_t a_read(struct file *f,          
                           char __user *ubuffer,   // buffer present in user space
                                                        
                           size_t length,          // length of the buffer     

                           loff_t *offset)
{
         
         int rand;
         get_random_bytes(&rand,sizeof(rand));
         adc_value=(rand%1024);                    //10-bit random no. generated 
         printk (KERN_INFO "\n Random no. generated is %d",adc_value); 
       
        int retval;
     switch (alignment) {
        case 'R':
        local_buffer = (adc_value);
        break;

        case 'L':
        local_buffer = (adc_value*64);
        break;
    }
        printk (KERN_INFO "\n Local buffer value=%d",local_buffer);
    

        retval = copy_to_user(ubuffer,&local_buffer,sizeof(local_buffer)); // passes data from local buffer(kernel) to user space buffer
    if (retval)    
        printk (KERN_INFO "\n Some data not copied to user buffer");
    else if (retval==0)
        printk (KERN_INFO "\n Data copied successfully to user buffer");
    

return 0;
    }


long a_ioctl(struct file *f,             
                  unsigned int ioctl_num,        /* number and param for ioctl */
                  unsigned long ioctl_param)
{
    int *userchannel;
    char *useralignment;
     
    switch (ioctl_num) {

    case IOCTL_SET_CHANNELNO:                //receive the channel no. from user 
        userchannel = (int*)ioctl_param;
        copy_from_user(&channel_no,userchannel,sizeof(channel_no));
        //copy_from_user(to,from,length);
        printk(KERN_INFO"\n Channel selected:%d",channel_no);
         break;

   


    case IOCTL_SET_ALIGNMENT:                //receive the alignment from user
       
         useralignment = (char*)ioctl_param;
         copy_from_user(&alignment,useralignment,sizeof(alignment));
        //copy_from_user(to,from,length);
        printk(KERN_INFO"\n Alignment selected:%c",alignment);
         break;

 
    }

  
}

static struct file_operations Fops = {
	.owner = THIS_MODULE,
        .read = a_read,
        .unlocked_ioctl = a_ioctl,
        .open = a_open,
        .release = a_release,     
};

 

static int __init myadc_init(void) 
{
	printk(KERN_INFO "\n Hello ! ADC8 char driver registered");
	
	// STEP 1 : reserve <major, minor>

	if (alloc_chrdev_region(&first, 0, 1, "8-CHANNEL 10-BIT ADC") < 0)
	{
		return -1;
	}
	
	// STEP 2 : dynamically create device node in /dev directory
    if ((cls = class_create(THIS_MODULE, "chardrv")) == NULL)
	{
		unregister_chrdev_region(first, 1);
		return -1;
	}
    if (device_create(cls, NULL, first, NULL, "adc8") == NULL)
	{
		class_destroy(cls);
		unregister_chrdev_region(first, 1);
		return -1;
	}
	
	// STEP 3 : Link Fops and cdev to device node
    cdev_init(&c_dev, &Fops);
    if (cdev_add(&c_dev, first, 1) == -1)
	{
		device_destroy(cls, first);
		class_destroy(cls);
		unregister_chrdev_region(first, 1);
		return -1;
	}
	return 0;
}
 
static void __exit myadc_exit(void) 
{
	cdev_del(&c_dev);
	device_destroy(cls, first);
	class_destroy(cls);
	unregister_chrdev_region(first, 1);
	printk(KERN_INFO "Bye: ADC8 char driver unregistered\n\n");
}
 
module_init(myadc_init);
module_exit(myadc_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Avanti Sapre");
MODULE_DESCRIPTION("Character driver for 10-bit 8-channel ADC");
